pred[baseline_vars, c(true_anchor, upstream_vars, anthro_vars)] <- 1
# Treatments predicted by everything before them
pred[treat_vars, c(true_anchor, upstream_vars, anthro_vars, baseline_vars)] <- 1
# Block downstream -> upstream
pred[upstream_vars, c(anthro_vars, baseline_vars, treat_vars)] <- 0
pred[anthro_vars,   treat_vars] <- 0
pred[baseline_vars, treat_vars] <- 0
# prevent baselineâ†”baseline circularity
pred[baseline_vars, baseline_vars] <- 0
diag(pred) <- 0
# Safety: every imputed var must have >=1 predictor
to_impute <- names(meth)[meth != ""]
bad <- to_impute[rowSums(pred[to_impute, , drop = FALSE]) == 0]
print(bad)
stopifnot(length(bad) == 0)
# -----------------------------
# 5) TWO-STAGE IMPUTATION
# -----------------------------
# Stage 1: initialize predictors so categorical models don't see NA covariates
stage1_vars <- unique(intersect(
c(upstream_vars, anthro_vars, "GGCEF_T0", "INT_T0", "MONTHS_OF_TREAT"),
names(meth)
))
meth1 <- meth
meth1[setdiff(names(meth1), stage1_vars)] <- ""  # only impute stage1 vars
meth1[true_anchor] <- ""                         # still never impute anchors
pred1 <- pred
pred1[,] <- 0
pred1[stage1_vars, true_anchor] <- 1
# allow stage1 vars to use each other ONLY if you want (usually not needed)
# pred1[stage1_vars, stage1_vars] <- 0
diag(pred1) <- 0
where1 <- is.na(df_baseline_clean)
imp_stage1 <- mice(
df_baseline_clean,
method          = meth1,
predictorMatrix = pred1,
where           = where1,
m               = 1,
maxit           = 10,
seed            = 123,
printFlag       = FALSE
)
df_stage1 <- complete(imp_stage1, 1)
# Stage 2: full imputation on top of initialized predictors
where2 <- is.na(df_stage1)
visit2 <- unique(c(upstream_vars, anthro_vars, baseline_vars, treat_vars, to_impute))
visit2 <- visit2[visit2 %in% to_impute]
imp <- mice(
df_stage1,
method          = meth,
predictorMatrix = pred,
where           = where2,
visitSequence   = visit2,
m               = 10,
maxit           = 20,
seed            = 123,
printFlag       = TRUE
)
# -----------------------------
# 6) Validate: imputed vars should have no NA
# -----------------------------
df1 <- complete(imp, 1)
should_be_complete <- names(imp$method)[imp$method != ""]
na_imputed <- colMeans(is.na(df1[, should_be_complete, drop = FALSE]))
print(na_imputed[na_imputed > 0])   # should be numeric(0)
# Optional diagnostics
plot(imp)
#TEST numerical
#--------------------------------------------------------
to_impute <- names(meth)[meth != ""]
visit_all <- to_impute
imp_default_order <- mice(
df_baseline_clean,
method = meth,
predictorMatrix = pred,
where = is.na(df_baseline_clean),
m = 10, maxit = 20, seed = 123,
printFlag = FALSE
)
imp_reverse_order <- mice(
df_baseline_clean,
method = meth,
predictorMatrix = pred,
where = is.na(df_baseline_clean),
visitSequence = rev(visit_all),
m = 10, maxit = 20, seed = 123,
printFlag = FALSE
)
vars_num <- names(meth)[meth == "pmm"]
mean_by_imp <- function(imp_obj, v) {
sapply(1:imp_obj$m, function(k) mean(complete(imp_obj, k)[[v]], na.rm = TRUE))
}
sd_by_imp <- function(imp_obj, v) {
sapply(1:imp_obj$m, function(k) sd(complete(imp_obj, k)[[v]], na.rm = TRUE))
}
cmp_num <- do.call(rbind, lapply(vars_num, function(v) {
mc <- mean_by_imp(imp, v)
md <- mean_by_imp(imp_default_order, v)
mr <- mean_by_imp(imp_reverse_order, v)
sc <- sd_by_imp(imp, v)
sd_ <- sd_by_imp(imp_default_order, v)
sr <- sd_by_imp(imp_reverse_order, v)
data.frame(
variable = v,
mean_current = mean(mc), mean_default = mean(md), mean_reverse = mean(mr),
absdiff_cur_def = abs(mean(mc) - mean(md)),
absdiff_cur_rev = abs(mean(mc) - mean(mr)),
sd_current = mean(sc), sd_default = mean(sd_), sd_reverse = mean(sr),
absdiff_sd_cur_def = abs(mean(sc) - mean(sd_)),
absdiff_sd_cur_rev = abs(mean(sc) - mean(sr)),
stringsAsFactors = FALSE
)
}))
cmp_num
# categorical variables that were imputed
cat_vars <- names(meth)[meth %in% c("logreg", "polyreg")]
cat_vars <- intersect(cat_vars, names(imp$imp))
prop_stability <- lapply(cat_vars, function(v) {
props <- sapply(1:imp$m, function(k) {
tab <- table(complete(imp, k)[[v]])
tab / sum(tab)
})
data.frame(
variable = v,
category = rownames(props),
mean_prop = rowMeans(props),
sd_prop   = apply(props, 1, sd)
)
})
prop_stability <- do.call(rbind, prop_stability)
prop_stability
compare_props <- function(imp_obj, var) {
sapply(1:imp_obj$m, function(k) {
prop.table(table(complete(imp_obj, k)[[var]]))
})
}
compare_props(imp, "T0_SYMPT_TREATMENT")
compare_props(imp_reverse_order, "T0_SYMPT_TREATMENT")
# Create a folder
dir.create("imputed_data", showWarnings = FALSE)
# Export each completed dataset
for (k in 1:imp$m) {
df_k <- complete(imp, k)
write.csv(
df_k,
file = sprintf("imputed_data/imputed_%02d.csv", k),
row.names = FALSE
)
}
should_be_complete <- names(imp$method)[imp$method != ""]
na_imputed <- colMeans(is.na(df1[, should_be_complete, drop = FALSE]))
na_imputed[na_imputed > 0]
fit1 <- with(imp, glm(Suspension ~ AGE + SEX + ANTIBODY + ..., family=binomial))
library(mice)
library(dplyr)
# ============================================================
# 1) CHOOSE YOUR MODEL (EDIT THIS)
# ============================================================
# Example binary outcome: Suspension
# Replace predictors with what you will report in your paper.
FORMULA <- Suspension ~ AGE + SEX + DIAGNOSIS + ANTIBODY + MONTHS_OF_TREAT +
GGCEF_T0 + INT_T0 + Hypertension + Sleep_Disorders
# ============================================================
# 2) Helper: fit + pool + extract tidy results
# ============================================================
pool_glm_extract <- function(mids_obj, formula, family = binomial()) {
fit_list <- with(mids_obj, glm(formula, family = family))
pooled   <- pool(fit_list)
s <- summary(pooled, conf.int = TRUE, exponentiate = FALSE)
# Add odds ratios (since logistic)
s <- s %>%
mutate(
OR        = exp(estimate),
OR_low95  = exp(`2.5 %`),
OR_high95 = exp(`97.5 %`)
)
list(
fit_list = fit_list,
pooled   = pooled,
summary  = s
)
}
# ============================================================
# 3) Run fits on the three imputations
# ============================================================
res_current <- pool_glm_extract(imp, FORMULA)
library(mice)
library(dplyr)
library(zoo)
library(tidyr)
library(miceadds)
exists("mice.impute.2l.pmm")
df_long$SUBJECT_ID <- as.integer(df_long$SUBJECT_ID)
MigraineLongitudianlVars <- read.csv("C:/Users/aless/Desktop/medical applications/data/raw/MigraineLongitudianlVars.csv", sep=";")
View(MigraineLongitudianlVars)
df_long$SUBJECT_ID <- as.integer(df_long$SUBJECT_ID)
View(MigraineLongitudianlVars)
df_long <- read.csv("C:/Users/aless/Desktop/medical applications/data/raw/MigraineLongitudianlVars.csv", sep=";")
View(df_long)
library(mice)
library(dplyr)
library(zoo)
library(tidyr)
library(miceadds)
exists("mice.impute.2l.pmm")
df_long$SUBJECT_ID <- as.integer(df_long$SUBJECT_ID)
df_long$CYCLE <- as.integer(df_long$CYCLE)
df_long$MONTH <- as.integer(df_long$MONTH)
# Drop derived variable (correct)
if ("RED_MMD_VST01" %in% names(df_long)) df_long <- subset(df_long, select = -RED_MMD_VST01)
cluster_var <- "SUBJECT_ID"
time_vars <- c("CYCLE","MONTH")
cont_vars <- c("MMDs","DOSE","GGFAR","HADSA","HADSD","HIT6","INT","MIDAS")
cont_vars <- intersect(cont_vars, names(df_long))
# Ensure numeric
for (v in cont_vars) df_long[[v]] <- as.numeric(df_long[[v]])
# Init
ini  <- mice(df_long, maxit=0, printFlag=FALSE)
meth <- ini$method
pred <- ini$predictorMatrix
# Methods
meth[cont_vars] <- "2l.pmm"
meth[c(cluster_var, time_vars)] <- ""   # do not impute ID/time
# Predictor matrix
pred[,] <- 0
pred[, cluster_var] <- -2               # random intercept per subject
# Time predicts outcomes
pred[cont_vars, time_vars] <- 1
# Outcomes predict each other (same timepoint)
pred[cont_vars, cont_vars] <- 1
diag(pred) <- 0
# time vars are not targets
pred[time_vars, ] <- 0
# Sanity check
to_impute <- names(meth)[meth != ""]
bad <- to_impute[rowSums(pred[to_impute, , drop=FALSE]) == 0]
print(bad)
stopifnot(length(bad) == 0)
# Run
imp_long <- mice(
df_long,
method = meth,
predictorMatrix = pred,
m = 20, maxit = 20, seed = 123,
printFlag = TRUE
)
plot(imp_long)
# One completed dataset for quick descriptive comparison
df_long_imp1 <- complete(imp_long, 1)
## -------------------------
df_locf <- df_long %>%
arrange(SUBJECT_ID, CYCLE, MONTH) %>%
group_by(SUBJECT_ID, CYCLE) %>%
fill(all_of(cont_vars), .direction = "down") %>%
ungroup()
df_nocb <- df_long %>%
arrange(SUBJECT_ID, CYCLE, MONTH) %>%
group_by(SUBJECT_ID, CYCLE) %>%
fill(all_of(cont_vars), .direction = "up") %>%
ungroup()
# Interpolate only continuous-like variables where it makes sense
interp_vars <- intersect(c("MMDs","HIT6","MIDAS"), names(df_long))
df_interp <- df_long %>%
arrange(SUBJECT_ID, CYCLE, MONTH) %>%
group_by(SUBJECT_ID, CYCLE) %>%
mutate(across(
all_of(interp_vars),
~ zoo::na.approx(.x, x = MONTH, na.rm = FALSE)
)) %>%
ungroup()
## -------------------------
## 3) Quick distribution comparison (one variable)
## -------------------------
compare_var <- function(var) {
rbind(
original = summary(df_long[[var]]),
locf     = summary(df_locf[[var]]),
nocb     = summary(df_nocb[[var]]),
interp   = summary(df_interp[[var]]),
mice     = summary(df_long_imp1[[var]])
)
}
compare_var("MMDs")
## -------------------------
## 4) Masking-based RMSE benchmark (properly aligned)
## -------------------------
calc_rmse <- function(true, imputed) {
sqrt(mean((true - imputed)^2, na.rm = TRUE))
}
# Build truth set with a stable row_id
truth_set <- df_long %>%
filter(!is.na(MMDs)) %>%
mutate(row_id = row_number())
set.seed(42)
n_mask  <- floor(0.2 * nrow(truth_set))
mask_ids <- sample(truth_set$row_id, n_mask)
test_data <- truth_set %>%
mutate(MMDs_masked = ifelse(row_id %in% mask_ids, NA, MMDs))
true_vals <- truth_set %>%
filter(row_id %in% mask_ids) %>%
pull(MMDs)
## ---- LOCF (within SUBJECT_ID, CYCLE)
locf_filled <- test_data %>%
arrange(SUBJECT_ID, CYCLE, MONTH) %>%
group_by(SUBJECT_ID, CYCLE) %>%
mutate(MMDs_f = zoo::na.locf(MMDs_masked, na.rm = FALSE)) %>%
ungroup() %>%
filter(row_id %in% mask_ids) %>%
pull(MMDs_f)
## ---- NOCB (within SUBJECT_ID, CYCLE)
nocb_filled <- test_data %>%
arrange(SUBJECT_ID, CYCLE, MONTH) %>%
group_by(SUBJECT_ID, CYCLE) %>%
mutate(MMDs_f = zoo::na.locf(MMDs_masked, fromLast = TRUE, na.rm = FALSE)) %>%
ungroup() %>%
filter(row_id %in% mask_ids) %>%
pull(MMDs_f)
## ---- Interpolation (within SUBJECT_ID, CYCLE)
interp_filled <- test_data %>%
arrange(SUBJECT_ID, CYCLE, MONTH) %>%
group_by(SUBJECT_ID, CYCLE) %>%
mutate(MMDs_f = zoo::na.approx(MMDs_masked, x = MONTH, na.rm = FALSE)) %>%
ungroup() %>%
filter(row_id %in% mask_ids) %>%
pull(MMDs_f)
## ---- MICE benchmark (multilevel, consistent with longitudinal structure)
mice_test_df <- test_data %>%
transmute(SUBJECT_ID, CYCLE, MONTH, MMDs = MMDs_masked)
ini2  <- mice(mice_test_df, maxit = 0, printFlag = FALSE)
meth2 <- ini2$method
pred2 <- ini2$predictorMatrix
meth2["MMDs"] <- "2l.pmm"
meth2[c("SUBJECT_ID","CYCLE","MONTH")] <- ""
pred2[,] <- 0
pred2["MMDs", "SUBJECT_ID"] <- -2
pred2["MMDs", c("CYCLE","MONTH")] <- 1
set.seed(123)
imp_test <- mice(
mice_test_df,
method = meth2,
predictorMatrix = pred2,
m = 1, maxit = 10,
printFlag = FALSE
)
mice_completed <- complete(imp_test, 1)
# Reattach row_id in original row order (mice keeps row order)
mice_filled <- mice_completed %>%
mutate(row_id = test_data$row_id) %>%
filter(row_id %in% mask_ids) %>%
pull(MMDs)
## ---- RMSE summary table
results <- data.frame(
Method = c("MICE_2l_pmm", "LOCF", "NOCB", "Interpolation"),
RMSE = c(
calc_rmse(true_vals, mice_filled),
calc_rmse(true_vals, locf_filled),
calc_rmse(true_vals, nocb_filled),
calc_rmse(true_vals, interp_filled)
)
)
print(results)
calc_rmse <- function(true, imputed) sqrt(mean((true - imputed)^2, na.rm = TRUE))
# RMSE for each imputation
rmse_mice_each <- sapply(1:m_imp, function(j) {
comp_j <- complete(imp_test, j)
filled_j <- comp_j %>%
mutate(row_id = test_data$row_id) %>%
filter(row_id %in% mask_ids) %>%
pull(MMDs)
calc_rmse(true_vals, filled_j)
})
m_imp <- 20
calc_rmse <- function(true, imputed) sqrt(mean((true - imputed)^2, na.rm = TRUE))
# RMSE for each imputation
rmse_mice_each <- sapply(1:m_imp, function(j) {
comp_j <- complete(imp_test, j)
filled_j <- comp_j %>%
mutate(row_id = test_data$row_id) %>%
filter(row_id %in% mask_ids) %>%
pull(MMDs)
calc_rmse(true_vals, filled_j)
})
m_imp<-20
calc_rmse <- function(true, imputed) {
sqrt(mean((true - imputed)^2, na.rm = TRUE))
}
## RMSE for each imputed dataset
rmse_mice_each <- sapply(seq_len(m_imp), function(j) {
comp_j <- complete(imp_test, j)
filled_j <- comp_j %>%
mutate(row_id = test_data$row_id) %>%   # reattach row_id (same row order)
filter(row_id %in% mask_ids) %>%
pull(MMDs)
calc_rmse(true_vals, filled_j)
})
m_imp <- 20
# Build MICE test data WITH row_id included
mice_test_df <- test_data %>%
transmute(
row_id,                  # keep it!
SUBJECT_ID,
CYCLE,
MONTH,
MMDs = MMDs_masked
)
ini2  <- mice(mice_test_df, maxit = 0, printFlag = FALSE)
meth2 <- ini2$method
pred2 <- ini2$predictorMatrix
# Impute only MMDs
meth2["MMDs"] <- "2l.pmm"
meth2[c("row_id","SUBJECT_ID","CYCLE","MONTH")] <- ""
# Predictor matrix
pred2[,] <- 0
pred2["MMDs", "SUBJECT_ID"] <- -2
pred2["MMDs", c("CYCLE","MONTH")] <- 1
# Ensure row_id is not used as a predictor (optional but clean)
pred2["MMDs", "row_id"] <- 0
set.seed(123)
imp_test <- mice(
mice_test_df,
method = meth2,
predictorMatrix = pred2,
m = m_imp,
maxit = 10,
printFlag = FALSE
)
calc_rmse <- function(true, imputed) sqrt(mean((true - imputed)^2, na.rm = TRUE))
# RMSE per imputation
rmse_mice_each <- sapply(seq_len(m_imp), function(j) {
comp_j <- complete(imp_test, j)
filled_j <- comp_j %>%
filter(row_id %in% mask_ids) %>%
pull(MMDs)
calc_rmse(true_vals, filled_j)
})
rmse_mice_mean <- mean(rmse_mice_each)
rmse_mice_sd   <- sd(rmse_mice_each)
# Pooled (posterior-mean) RMSE
filled_matrix <- sapply(seq_len(m_imp), function(j) {
complete(imp_test, j) %>%
filter(row_id %in% mask_ids) %>%
pull(MMDs)
})
mice_pooled_mean <- rowMeans(filled_matrix, na.rm = TRUE)
rmse_mice_pooled <- calc_rmse(true_vals, mice_pooled_mean)
cat("MICE RMSE across imputations:\n")
cat("  mean =", rmse_mice_mean, "\n")
cat("  sd   =", rmse_mice_sd, "\n\n")
cat("MICE pooled-mean RMSE =", rmse_mice_pooled, "\n")
first_minus_last <- function(data) {
data %>%
group_by(SUBJECT_ID, CYCLE) %>%
summarise(
diff_mmd = MMDs[which.min(MONTH)] - MMDs[which.max(MONTH)],
.groups = "drop"
)
}
# 1) Run the analysis model in each imputed dataset
fit <- with(imp_long, {
d <- first_minus_last(data)
lm(diff_mmd ~ 1, data = d)   # intercept-only => mean reduction
})
library(mice)
library(dplyr)
library(zoo)
library(tidyr)
library(miceadds)
exists("mice.impute.2l.pmm")
first_minus_last <- function(data) {
data %>%
group_by(SUBJECT_ID, CYCLE) %>%
summarise(
diff_mmd = MMDs[which.min(MONTH)] - MMDs[which.max(MONTH)],
.groups = "drop"
)
}
# 1) Run the analysis model in each imputed dataset
fit <- with(imp_long, {
d <- first_minus_last(data)
lm(diff_mmd ~ 1, data = d)   # intercept-only => mean reduction
})
first_minus_last <- function(df) {
df %>%
group_by(SUBJECT_ID, CYCLE) %>%
summarise(
diff_mmd = MMDs[which.min(MONTH)] - MMDs[which.max(MONTH)],
.groups = "drop"
)
}
fit <- with(imp_long, {
dfk <- data.frame(SUBJECT_ID, CYCLE, MONTH, MMDs)  # <-- create an actual data frame
d   <- first_minus_last(dfk)
lm(diff_mmd ~ 1, data = d)                         # mean reduction = intercept
})
pooled <- pool(fit)
summary(pooled, conf.int = TRUE)
fit_cycle <- with(imp_long, {
dfk <- data.frame(SUBJECT_ID, CYCLE, MONTH, MMDs)
d   <- first_minus_last(dfk)
lm(diff_mmd ~ factor(CYCLE) - 1, data = d)
})
summary(pool(fit_cycle), conf.int = TRUE)
library(lme4)
fit_baseline_trend <- with(imp_long, {
dfk <- data.frame(SUBJECT_ID, CYCLE, MONTH, MMDs)
dfb <- dfk[dfk$MONTH == 1, ]  # baseline within each cycle
# Treat cycle as ordered numeric (tests linear trend C1 -> C2 -> C3)
lmer(MMDs ~ as.numeric(CYCLE) + (1 | SUBJECT_ID), data = dfb)
})
pooled_baseline_trend <- pool(fit_baseline_trend)
summary(pooled_baseline_trend, conf.int = TRUE)
